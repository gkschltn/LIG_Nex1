#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#define STATUS 0x92
#define VELO 0x64
#define COO 350
#define NUMPIXELS 8      // LED 개수

// 비트 전송 지연 시간 (마이크로초)
#define T0H 0.4       // 0 비트의 High 시간
#define T0L 0.85         // 0 비트의 Low 시간
#define T1H 0.8        // 1 비트의 High 시간
#define T1L 0.45          // 1 비트의 Low 시간

volatile unsigned int cnt = 0;

// 키패드 핀 설정
#define ROW_MASK 0x1F    // PC0 ~ PC4 (5개의 행)
#define COL_PD_MASK 0x7C // PD0 ~ PD4 (5개의 열)
#define COL_PB_MASK 0x87 // PB0, PB1, PB7 (3개의 열, PB2 -> PB7로 변경)

void SPI_Transmit(uint8_t data) {
	// Start transmission
	SPDR = data;
	// Wait for transmission complete
	while(!(SPSR & (1<<SPIF)));
}

void sendByte(uint8_t byte) {
	for (uint8_t i = 0; i < 8; i++) {
		if (byte & (1 << (7 - i))) {
			PORTB |= (1 << PB3);     // 데이터 핀 HIGH
			_delay_us(T1H);          // 1 비트의 High 시간
			PORTB &= ~(1 << PB3);    // 데이터 핀 LOW
			_delay_us(T1L);
			// 1 비트의 Low 시간
			} else {
			PORTB &= ~(1 << PB3);    // 데이터 핀 LOW
			_delay_us(T0H);          // 0 비트의 High 시간
			PORTB |= (1 << PB3);     // 데이터 핀 HIGH
			_delay_us(T0L);       // 0 비트의 Low 시간
		}
	}
}

void sendColor(uint8_t red, uint8_t green, uint8_t blue) {
	sendByte(green); // NeoPixel은 GRB 순서로 데이터를 받음
	sendByte(red);
	sendByte(blue);
}
void UART_init(unsigned int ubrr) {
	UBRR0H = (unsigned char)(ubrr>>8);
	UBRR0L = (unsigned char)ubrr;
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
	UCSR0C = (1<<USBS0)|(3<<UCSZ00);
}

void UART_transmit(unsigned char data) {
	while (!(UCSR0A & (1<<UDRE0)));
	UDR0 = data;
}

unsigned char UART_receive(void) {
	while (!(UCSR0A & (1<<RXC0)));
	return UDR0;
}
ISR(TIMER0_OVF_vect) {
	TCNT0 = 0x06;  // 타이머 초기화
	cnt++;
	if (cnt < 250) {
		PORTC |= (1 << PC5);  // LED 켜기
		} else if (cnt < 500) {
		PORTC &= ~(1 << PC5); // LED 끄기
		} else {
		cnt = 0; // 카운터 초기화
	}
}


// 키패드 초기화 함수
void keypad_init() {
	// 행 (PC0 ~ PC4) 출력으로 설정, 초기값 HIGH
	DDRC |= ROW_MASK;    // PC0 ~ PC4 출력
	PORTC |= ROW_MASK;   // 기본값 HIGH

	// 열 (PD0 ~ PD4) 입력으로 설정, 풀업 저항 활성화
	DDRD &= ~COL_PD_MASK; // PD0 ~ PD4 입력
	PORTD |= COL_PD_MASK; // 풀업 저항 활성화

	// 열 (PB0, PB1, PB7) 입력으로 설정, 풀업 저항 활성화
	DDRB &= ~COL_PB_MASK; // PB0, PB1, PB7 입력
	PORTB |= COL_PB_MASK; // 풀업 저항 활성화

}


// 키패드 스캔 함수
uint8_t scan_keypad() {
	uint8_t col, row;

	for (row = 0; row < 5; row++) { // 5개의 행 스캔
		// 모든 행 HIGH로 설정 후, 현재 행만 LOW로 설정
		PORTC = (PORTC | ROW_MASK) & ~(1 << row);
		_delay_ms(1); // 안정화 시간

		// 열 확인 (PD0 ~ PD4)
		for (col = 2; col < 7; col++) {
			if (!(PIND & (1 << col))) { // LOW 감지
				return (row * 8) + col -1;
			}
		}

		// 열 확인 (PB0, PB1, PB7)
		//6>1 14>9 22/17 30/25
		if (!(PINB & (1 << 0))) { // PB0 LOW 감지
			return (row * 8) + 6; // 열 번호
		}
		if (!(PINB & (1 << 1))) { // PB1 LOW 감지
			return (row * 8) + 7; // 열 번호 7
		}
		if (!(PINB & (1 << 7))) { // PB7 LOW 감지
			return (row * 8) + 8; // 열 번호 8
		}
		
	}

	return 0; // 입력 없음
}

int res(){
	int digit = 0;
	int key = -1;
	key = scan_keypad(); // 키패드 스캔
	int key_1st = -1;
	int key_2nd = 0;
	
	if((key % 8) == 5){
		key_2nd = 1;
		} else if((key % 8) == 4){
		key_2nd = 2;
		} else if((key % 8) == 3){
		key_2nd = 3;
		} else if((key % 8) == 7){
		key_2nd = 4;
		} else if((key % 8) == 0){
		key_2nd = 5;
		} else if((key % 8) == 6){
		key_2nd = 6;
		} else if((key % 8) == 2){
		key_2nd = 7;
		} else if((key % 8) == 1){
		key_2nd = 8;
		} else{}
		
		if((key / 8) == 0 && (key % 8) != 0) {
			key_1st = 0;
			} else if((key/8) == 1 && (key % 8) == 0) {
			key_1st = 0;
			} else if((key/8) == 1 && (key % 8) != 0) {
			key_1st = 1;
			} else if((key/8) == 2 && (key % 8) == 0) {
			key_1st = 1;
			} else if((key/8) == 2 && (key % 8) != 0) {
			key_1st = 4;
			} else if((key/8) == 3 && (key % 8) == 0) {
			key_1st = 4;
			} else if((key/8) == 3 && (key % 8) != 0) {
			key_1st = 3;
			} else if((key/8) == 4 && (key % 8) == 0) {
			key_1st = 3;
			}  else if((key/8) == 4 && (key % 8) != 0) {
			key_1st = 2;
			} else if((key/8) == 5 && (key % 8) == 0) {
			key_1st = 2;
		}
		
		return digit = key_1st * 8 + key_2nd;
	}


	int main(void) {
		int digit = 0;
		DDRB |= (1 << PB3);
		PORTB &= ~(1 << PB3);
		
		keypad_init(); // 키패드 초기화
		UART_init(31); //보더레이트 31250
		
		/*TCNT0 = 0x00;
		TCCR0B = 0x03;  // 분주비 64 설정
		TIMSK0 = 0x01;  // 타이머 오버플로우 인터럽트 활성화
		SREG = 0x80;    // 전역 인터럽트 활성화*/

		DDRC |= (1 << PC5);  // Pc5: 출력 설정
		while (1) {
			digit=res();
			
			uint16_t note = 0x2f + digit;
			
			
			if (digit > 0)
			{
	
				for(int i =0; i < digit * 7 + 20; i++){
					sendColor(0, 125, 0);
				}
			
				
				
				UART_transmit(STATUS);
				UART_transmit(note);
				UART_transmit(VELO);
				_delay_ms(COO);
				
				UART_transmit(STATUS);
				UART_transmit(note);
				UART_transmit(0x00);
				
				
				
			}
			else {

			}
			
		}
		return 0;
		
	}