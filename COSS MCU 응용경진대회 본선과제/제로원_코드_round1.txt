#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

volatile unsigned int cnt = 0;

#define DATA_PIN    PD5
#define CLOCK_PIN   PD6
#define LATCH_PIN   PD7

// 키패드 핀 설정
#define ROW_MASK 0x1F    // PC0 ~ PC4 (5개의 행)
#define COL_PD_MASK 0x7C // PD0 ~ PD4 (5개의 열)
#define COL_PB_MASK 0x87 // PB0, PB1, PB7 (3개의 열, PB2 -> PB7로 변경)




// 7세그먼트 디스플레이에 해당하는 비트 패턴 (0~9)
uint8_t seg_digits[] = {
   0xc0,  // 0
   0xf9,  // 1
   0xa4,  // 2
   0xb0,  // 3
   0x99,  // 4
   0x92,  // 5
   0x82,  // 6
   0xf8,  // 7
   0x80,  // 8
   0x90   // 9
};

uint8_t dot_digits[37][8] ={
   {0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C}, // 1
   {0x3C, 0x42, 0x02, 0x04, 0x18, 0x20, 0x40, 0x7E}, // 2
   {0x3C, 0x42, 0x02, 0x1C, 0x02, 0x02, 0x42, 0x3C}, // 3
   {0x08, 0x18, 0x28, 0x48, 0x7E, 0x08, 0x08, 0x08}, // 4
   {0x7E, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x42, 0x3C}, // 5
   {0x3C, 0x42, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x3C}, // 6
   {0x7E, 0x42, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10}, // 7
   {0x3C, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x42, 0x3C}, // 8
   {0x3C, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x42, 0x3C},  // 9
   {0x26, 0x69, 0xa9, 0x29, 0x29, 0x29, 0x29, 0x76}, // 10
   {0x22, 0x66, 0xaa, 0x22, 0x22, 0x22, 0x22, 0x77}, // 11
   {0x26, 0x69, 0xa1, 0x21, 0x22, 0x24, 0x28, 0x6f}, // 12
   {0x26, 0x69, 0xa1, 0x26, 0x21, 0x21, 0x29, 0x66}, // 13
   {0x22, 0x66, 0xaa, 0x32, 0x3f, 0x22, 0x22, 0x62}, // 14
   {0x2e, 0x68, 0xa8, 0x2e, 0x21, 0x21, 0x29, 0x66}, // 15
   {0x26, 0x69, 0xa8, 0x2e, 0x29, 0x29, 0x29, 0x66}, // 16
   {0x2f, 0x69, 0xa9, 0x21, 0x21, 0x21, 0x21, 0x61}, //17
   {0x26, 0x69, 0xa9, 0x26, 0x29, 0x29, 0x29, 0x66}, //18
   {0x26, 0x69, 0xa9, 0x27, 0x21, 0x21, 0x29, 0x66}, //19
   {0x66, 0x99, 0x99, 0x19, 0x69, 0x89, 0x89, 0xf6}, //20
   {0x62, 0x96, 0x9a, 0x12, 0x62, 0x82, 0x82, 0xf7}, //21
   {0x66, 0x99, 0x99, 0x11, 0x62, 0x84, 0x88, 0xff}, //22
   {0x66, 0x99, 0x91, 0x16, 0x61, 0x81, 0x89, 0xf6}, //23
   {0x62, 0x96, 0x9a, 0x1a, 0x6f, 0x82, 0x82, 0xf2}, //24
   {0x6e, 0x98, 0x98, 0x1e, 0x61, 0x81, 0x89, 0xf6}, //25
   {0x66, 0x99, 0x98, 0x1e, 0x69, 0x89, 0x89, 0xf6}, //26
   {0x6f, 0x99, 0x99, 0x11, 0x61, 0x81, 0x81, 0xf1}, //27
   {0x66, 0x99, 0x99, 0x16, 0x69, 0x89, 0x89, 0xf6}, //28
   {0x66, 0x99, 0x99, 0x17, 0x61, 0x81, 0x89, 0xf6}, //29
   {0x66, 0x99, 0x19, 0x69, 0x19, 0x19, 0x99, 0x66}, //30
   {0x62, 0x96, 0x1a, 0x62, 0x12, 0x12, 0x92, 0x67}, //31
   {0x66, 0x99, 0x11, 0x61, 0x16, 0x18, 0x98, 0x6f}, //32
   {0x66, 0x99, 0x11, 0x66, 0x11, 0x11, 0x99, 0x66}, //33
   {0x62, 0x96, 0x1a, 0x6f, 0x12, 0x12, 0x92, 0x62}, //34
   {0x6f, 0x98, 0x18, 0x66, 0x11, 0x11, 0x99, 0x66}, //35
   {0x66, 0x99, 0x18, 0x6e, 0x19, 0x19, 0x99, 0x66}, //36
   {0x6f, 0x99, 0x11, 0x61, 0x11, 0x11, 0x91, 0x61}//37
};

// 
void SPI_Init() {
   DDRB |= (1<<PB2)|(1<<PB3)|(1<<PB5);  // SS, MOSI, SCK를 출력으로 설정
   SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0); // SPI 활성화, 마스터 모드, 클럭 분주비 16
   SPSR &= ~(1<<SPI2X);                 // 2배속 모드 비활성화
   
}

void SPI_Transmit(uint8_t data) {
   SPDR = data;
   while(!(SPSR & (1<<SPIF)));
}

void MAX7219_Send(uint8_t address, uint8_t data) {
   PORTB &= ~(1<<PB2);  // SS 핀 LOW
   SPI_Transmit(address);
   SPI_Transmit(data);
   PORTB |= (1<<PB2);   // SS 핀 HIGH
}

void MAX7219_Init() {
   MAX7219_Send(0x09, 0x00);  // 디코드 모드 해제
   MAX7219_Send(0x0A, 0x01);  // 밝기 설정 (최대)
   MAX7219_Send(0x0B, 0x07);  // 스캔 제한 설정
   MAX7219_Send(0x0C, 0x01);  // 셧다운 모드 해제
   MAX7219_Send(0x0F, 0x00);  // 디스플레이 테스트 모드 해제
}

void display_byte(uint8_t im[8]) {
   for(uint8_t i = 0; i < 8; i++) {
      MAX7219_Send(i + 1, im[i]);
   }
}

ISR(TIMER0_OVF_vect) {
   TCNT0 = 0x06;  // 타이머 초기화
   cnt++;
   if (cnt < 250) {
      PORTC |= (1 << PC5);  // LED 켜기
      } else if (cnt < 500) {
      PORTC &= ~(1 << PC5); // LED 끄기
      } else {
      cnt = 0; // 카운터 초기화
   }
}

void shiftOut(uint8_t data) {
   for (uint8_t i = 0; i < 8; i++) {
      if (data & (1 << (7 - i))) {
         PORTD |= (1 << DATA_PIN);
         } else {
         PORTD &= ~(1 << DATA_PIN);
      }
      PORTD |= (1 << CLOCK_PIN);
      PORTD &= ~(1 << CLOCK_PIN);
   }
}

void displayDigit(uint8_t digit) {
   if (digit < 10) {
      uint8_t data = seg_digits[digit];
      PORTD &= ~(1 << LATCH_PIN);
      shiftOut(data);
      PORTD |= (1 << LATCH_PIN);
   }
}

void off(){
   uint8_t data = 0xFF;
   PORTD &= ~(1 << LATCH_PIN);
   shiftOut(data);
   PORTD |= (1 << LATCH_PIN);
}

// 키패드 초기화 함수
void keypad_init() {
   // 행 (PC0 ~ PC4) 출력으로 설정, 초기값 HIGH
   DDRC |= ROW_MASK;    // PC0 ~ PC4 출력
   PORTC |= ROW_MASK;   // 기본값 HIGH

   // 열 (PD0 ~ PD4) 입력으로 설정, 풀업 저항 활성화
   DDRD &= ~COL_PD_MASK; // PD0 ~ PD4 입력
   PORTD |= COL_PD_MASK; // 풀업 저항 활성화

   // 열 (PB0, PB1, PB7) 입력으로 설정, 풀업 저항 활성화
   DDRB &= ~COL_PB_MASK; // PB0, PB1, PB7 입력
   PORTB |= COL_PB_MASK; // 풀업 저항 활성화

}


// 키패드 스캔 함수
uint8_t scan_keypad() {
   uint8_t col, row;

   for (row = 0; row < 5; row++) { // 5개의 행 스캔
      // 모든 행 HIGH로 설정 후, 현재 행만 LOW로 설정
      PORTC = (PORTC | ROW_MASK) & ~(1 << row);
      _delay_ms(1); // 안정화 시간

      // 열 확인 (PD0 ~ PD4)
      for (col = 2; col < 7; col++) {
         if (!(PIND & (1 << col))) { // LOW 감지
            return (row * 8) + col -1;
         }
      }

      // 열 확인 (PB0, PB1, PB7)
      //6>1 14>9 22/17 30/25
      if (!(PINB & (1 << 0))) { // PB0 LOW 감지
         return (row * 8) + 6; // 열 번호
      }
      if (!(PINB & (1 << 1))) { // PB1 LOW 감지
         return (row * 8) + 7; // 열 번호 7
      }
      if (!(PINB & (1 << 7))) { // PB7 LOW 감지
         return (row * 8) + 8; // 열 번호 8
      }
      
   }

   return 0; // 입력 없음
}

int res(){
   int digit = 0;
   int key = -1;
   key = scan_keypad(); // 키패드 스캔
   int key_1st = -1;
   int key_2nd = 0;
   
   if((key % 8) == 5){
      key_2nd = 1;
      } else if((key % 8) == 4){
      key_2nd = 2;
      } else if((key % 8) == 3){
      key_2nd = 3;
      } else if((key % 8) == 7){
      key_2nd = 4;
      } else if((key % 8) == 0){
      key_2nd = 5;
      } else if((key % 8) == 6){
      key_2nd = 6;
      } else if((key % 8) == 2){
      key_2nd = 7;
      } else if((key % 8) == 1){
      key_2nd = 8;
      } else{}
      
      if((key / 8) == 0 && (key % 8) != 0) {
         key_1st = 0;
         } else if((key/8) == 1 && (key % 8) == 0) {
         key_1st = 0;
         } else if((key/8) == 1 && (key % 8) != 0) {
         key_1st = 1;
         } else if((key/8) == 2 && (key % 8) == 0) {
         key_1st = 1;
         } else if((key/8) == 2 && (key % 8) != 0) {
         key_1st = 4;
         } else if((key/8) == 3 && (key % 8) == 0) {
         key_1st = 4;
         } else if((key/8) == 3 && (key % 8) != 0) {
         key_1st = 3;
         } else if((key/8) == 4 && (key % 8) == 0) {
         key_1st = 3;
         }  else if((key/8) == 4 && (key % 8) != 0) {
         key_1st = 2;
         } else if((key/8) == 5 && (key % 8) == 0) {
         key_1st = 2;
      }
      
      return digit = key_1st * 8 + key_2nd;
   }


   int main(void) {
      // 포트 설정
      DDRD = (1 << DATA_PIN) | (1 << CLOCK_PIN) | (1 << LATCH_PIN);
      keypad_init(); // 키패드 초기화
      SPI_Init();
      MAX7219_Init();
      
      


      TCNT0 = 0x00;
      TCCR0B = 0x03;  // 분주비 64 설정
      TIMSK0 = 0x01;  // 타이머 오버플로우 인터럽트 활성화
      SREG = 0x80;    // 전역 인터럽트 활성화

      DDRC |= (1 << PC5);  // Pc5: 출력 설정
      
      while (1) {
         int digit=res();
         if (digit > 0)  {
            display_byte(dot_digits[digit-1]);
            _delay_ms(200);
         }
         else{}
      }
      return 0;
   }